if (dataset != null) {
if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); }
if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); }
copy.data = new java.util.ArrayList();
if (this.data.size() > 0) {
Collection c = r.getAnnotations();Iterator i = c.iterator();while (i.hasNext()) {XYAnnotation a = (XYAnnotation) i.next();if (a instanceof XYAnnotationBoundsInfo) {includedAnnotations.add(a);}}
if (index >= 0 && !this.allowDuplicateXValues) {
return super.equals(obj);
long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime();
long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime();
this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());
if (endIndex < 0) {
return " title=\"" + toolTipText + "\" alt=\"\"";
PathIterator iterator2 = p1.getPathIterator(null);
this.dataset = dataset;
RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED);
boolean removed = markers.remove(marker);
boolean removed = markers.remove(marker);
boolean removed = markers.remove(marker);
boolean removed = markers.remove(marker);
Iterator iterator = this.dataset.getKeys().iterator();
state.setTotal(DatasetUtilities.calculatePieDatasetTotal( plot.getDataset()));
this.seriesKeys = null;
this.categoryKeys = null;
if (categoryKeys.length != this.startData[0].length) {
Object clone = createCopy(0, getItemCount() - 1);
if (index < this.keys.size()) {
return;
rowData.removeValue(columnKey);
return this.domainAxes.indexOf(axis);
int result = this.rangeAxes.indexOf(axis);
super(paint, stroke, paint, stroke, alpha);
double minval = Double.NaN; if (item.getMinOutlier() != null) { minval = item.getMinOutlier().doubleValue(); } double maxval = Double.NaN; if (item.getMaxOutlier() != null) { maxval = item.getMaxOutlier().doubleValue(); }  if (Double.isNaN(this.maximumRangeValue)) { this.maximumRangeValue = maxval; this.maximumRangeValueRow = r; this.maximumRangeValueColumn = c; } else if (maxval > this.maximumRangeValue) { this.maximumRangeValue = maxval; this.maximumRangeValueRow = r; this.maximumRangeValueColumn = c; }  if (Double.isNaN(this.minimumRangeValue)) { this.minimumRangeValue = minval; this.minimumRangeValueRow = r; this.minimumRangeValueColumn = c; } else if (minval < this.minimumRangeValue) { this.minimumRangeValue = minval; this.minimumRangeValueRow = r; this.minimumRangeValueColumn = c; }
this.minimumRangeValue = Double.NaN; this.maximumRangeValue = Double.NaN;
if (row >= 0) {
return rowData.getObject(columnKey);
removeRow(index);
rowData.removeValue(columnKey);
int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0);
double value = meanValue.doubleValue();
double valueDelta = dataset.getStdDevValue(row, column).doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation);
double value = meanValue.doubleValue();
double valueDelta = dataset.getStdDevValue(row, column).doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation);
EntityCollection entities = owner.getEntityCollection();if (entities != null) {entities.add(new AxisLabelEntity(this, hotspot,this.labelToolTip, this.labelURL));}
Node function = fnScope.getRootNode();
currentPropertyNames = implicitProto.getOwnPropertyNames();
if (c.canInline()) {
private boolean canInline() {
switch (input.getType()) {
return false;
if (detectImplicitPrototypeCycle()) {
if (detectImplicitPrototypeCycle()) {
String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else {
}
if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else {
}
return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;
return var != null && var.getScope() == s && !blacklistedVars.contains(var);
if (filename.indexOf(filenamePrefix) == 0) {
String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));
return allResultsMatch(n, MAY_BE_STRING_PREDICATE);
} else if (n.getJSType() != null && parent.isAssign()) { return;
return false;
traverse(c); Node next = c.getNext();
cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
typeReference.setString(aliasName);
aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));
if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
if (options.dependencyOptions.needsManagement() && options.closurePass) {
switch (node.getType()) {
default: throw new IllegalArgumentException("Node cannot be refined. \n" + node.toStringTree());
if (value != null) { Node addition = IR.add( IR.string("").srcref(callTarget), value.detachFromParent());
if (n.isExprResult()) {
if (parent.getType() == Token.COMMA) { if (isResultUsed) { return; } if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; } } if (
if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); if (gramps.isCall() && parent == gramps.getFirstChild()) { if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && "eval".equals(n.getNext().getString())) { return; }
if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) { } else { return; }
if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } else if (n.isExprResult()) { return; }
for (int i = 0; current != null && i < intIndex; i++) {
if (parent.isVar()) {
if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
Node constructor = n.getFirstChild(); scope = traverse(constructor, scope);
for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { scope = traverse(arg, scope); }
Node moduleExportsProp = IR.getprop(IR.name(moduleName),
Preconditions.checkState(tryBody.isLabelName());
Preconditions.checkState(finallyBody.isLabelName());
Node catchBody = block(catchNode).copyInformationFrom(catchNode);
continue;
Node childVal = child.getFirstChild();
(new NodeTraversal(compiler, this)).traverse(root);
if (n.isName() && jsScope.isDeclared(n.getString(), true)) {
for (Var s : def.depends) {
if (options.dependencyOptions.needsManagement() && !options.skipAllPasses && options.closurePass) {
if (builder.length() > 0) { builder.append(' '); }
if (constraintObj.isRecordType()) {
addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p + 1, rhsContext);
cc.listSeparator();
if (getLastChar() != ' ') {
if (constraintObj != null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } }
return canMoveAggressively(value) || canMoveModerately(initialization, reference);
Preconditions.checkState(body.getNext() == null && body.isBlock());
parseDirectives(bodyNode);
if (x < 0 && prev == '-') {
sb.append(getPropertyType(property).toString());
if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
return "{...}";
JsName name = getName(ns.name, false);
if (name != null) {
}
parametersNode = paramBuilder.build();
if (templateTypeName != null && !foundTemplateType) {
return newNode( Token.FOR, transform(loopNode.getIterator()), transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody()));
defineObjectLiteral(n);
append(newcode);
if (assignedToUnknownValue && hasPropertyAssign) {
this.maybeAliased = !assignNode.getParent().isExprResult();
@Override public JSType getLeastSupertype(JSType that) { if (!that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); }
Builder x = OriginalMapping.newBuilder() .setOriginalFile(sources[entry.getSourceFileId()]) .setLineNumber(entry.getSourceLine()) .setColumnPosition(entry.getSourceColumn());
generator.addMapping( sourceFile, originalName, new FilePosition(node.getLineno(), node.getCharno()), outputStartPosition, outputEndPosition);
if (inferred) { // Determining declaration for #2 inferred = !(rhsValue != null && rhsValue.isFunction() && (info != null || !scope.isDeclared(qName, false)));
if (declarationRoot.getType() == Token.FUNCTION) { for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); }  else
switch (n.getType()) { case Token.FUNCTION:
if (!NodeUtil.isImmutableValue(right)) {
String joinString = (right == null) ? "," : NodeUtil.getStringValue(right);
if ((long) x == x) {
return len > 0;
nodes.add(new Node(Token.TRUE));
if (!qVar.isTypeInferred()) {
if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {
boolean replacedPrototype = prototype != null;
return NodeUtil.isFunctionExpression(n);
return null;
if (target != null) {
addToSetIfLocal(lhs, kill); addToSetIfLocal(lhs, gen);
if (options.checkGlobalThisLevel.isOn()) {
switch (n.getType()) {
return TernaryValue.FALSE;
if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) {
if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) {
String code = toSource(root, sourceMap);
builder.setTagAsStrict( options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);
case '\0': sb.append("\\0"); break;
if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
break;
if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP ) {
token = eatTokensUntilEOL();}
return reportGenericTypeSyntaxWarning();
return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");
visitParameterList(t, n, functionType);
defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), true);
boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;
}
if (li.referenced) {
if (c > 0x1f && c <= 0x7f) {
int lhType = left.getType();
int rhType = right.getType();
String s = trimJsWhiteSpace(rawJsString);
return TernaryValue.TRUE;
case Token.AND:
case Token.HOOK:
if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {
if (NodeUtil.isName(n) && variable.equals(n.getString())) {
case Token.AND:
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
case '\n': sb.append("\\n"); break;
error(DiagnosticType.error("JSC_DIVIDE_BY_0_ERROR", "Divide by 0"), right);
error(DiagnosticType.error("JSC_DIVIDE_BY_0_ERROR", "Divide by 0"), right);
new NodeTraversal( compiler, new NormalizeStatements(compiler, assertOnChange)) .traverse(root);
private void createSynthesizedExternVar(String varName) { Node nameNode = Node.newString(Token.NAME, varName);  // Mark the variable as constant if it matches the coding convention // for constant vars. // NOTE(nicksantos): honestly, i'm not sure how much this matters. // AFAIK, all people who use the CONST coding convention also // compile with undeclaredVars as errors. We have some test // cases for this configuration though, and it makes them happier. if (compiler.getCodingConvention().isConstant(varName)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); }  getSynthesizedExternsRoot().addChildToBack( new Node(Token.VAR, nameNode)); varsToDeclareInExterns.remove(varName);
return true;
case Token.IN:
name = new Name();
return isNoType() || isNoObjectType() || isNoResolvedType();
String param = params.getParameter(0);
return assign;
Node node = newNode(type, operand);
if (n.getParent() == null) { List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges(); if (outEdges.size() == 1) { return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue()); } }
case Token.BLOCK: if (n.hasChildren()) { Node first = n.getFirstChild(); return tryRemoveUnconditionalBranching(first); } else { return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n)); }
Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));
return next;
return true;
return NodeUtil.isExpressionNode(maybeExpr);
return VariableLiveness.KILL;
Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName());
if (type != Type.FUNCTION && aliasingGets > 0) {
if (!type.isSubtype(
if (maybeTypeOfThis instanceof ObjectType) {
if (parent != null && parent.getType() == Token.ASSIGN) {
int indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace.indexOf('.');
switch (val.getType()) {
return false;
if (scopeToDeclareIn.isDeclared(variableName, false)) {
while (arguments.hasNext() && parameters.hasNext()) {
parameter = parameters.next();
result = lvalInt >>> rvalInt;
return true;
this.parent = parent;  // only named functions may be hoisted. this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);
if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType() || jsDoc.isOverride())) {
if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals("prototype")) { return false; } if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(".prototype.")) {
if (parent != null && parent.getType() == Token.ASSIGN) {
return false;
if (flags.process_closure_primitives) { options.closurePass = true; }  initOptionsFromFlags(options);
if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } removeDuplicateDeclarations(root);
switch (n.getType()) {
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
return foundType;
if (result != null) {
StringBuilder sb = new StringBuilder();
if (sb.length() > 0) {
if (sb.length() > 0) {
sb = new StringBuilder();
if (sb.length() > 0) {
if (isClassOrEnum) { return true; } return (type == Type.FUNCTION || aliasingGets == 0) && (parent == null || parent.canCollapseUnannotatedChildNames());
if (parseDocumentation) {
return options;
if (info != null) {
return parseTypeName(token);
} else if (isVar) { Node grandparent = parent.getParent(); Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null; Node varNode = parent;
if (value != null || v.getJSDocInfo() != null) {
grandparent.addChildBefore(newDecl, varNode);
while (n.next != child) {
return topType;
Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);
if (provided != null) {
recordDepScope(recordNode, ns);
if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); } }
if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; }
Node cArg = callNode.getFirstChild().getNext();
if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) {
if (n.isGetProp()) {
JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } } if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); }
String name = child.getString();
case Token.INC:
break;
if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) {
if (comment.getValue().indexOf("/* @") != -1 || comment.getValue().indexOf("\n * @") != -1) {
Context rhsContext = Context.OTHER;
node = node.getFirstChild();
if (fnType != null) {
if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }
if (nextCfgNode == fallThrough) {
for (int index = 0; index < len; index++) {
return len > 0 && s.charAt(0) != '0';
if (!NodeUtil.isGet(first)) {
if (name.globalSets == 1 && name.localSets == 0 &&
if (length == 0 || !Character.isJavaIdentifierStart(s.charAt(0))) {
if ( !Character.isJavaIdentifierPart(s.charAt(i))) {
if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can // proceed even if there are side effects... !mayEffectMutableState(lhs)) {
return result;
final int hexDigits = str.length() - pfxLen;
if (hexDigits > 16) { // too many for Long
if (hexDigits > 8) { // too many for an int
final int len = str.length();
final Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; }
final Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; }
this.lookupMap.put(seq[0], seq[1]);
final CharSequence result = lookupMap.get(subSeq);
final char ch0 = str.charAt(0);
final char ch1 = str.charAt(1); if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (len == 2) { return new Locale(str); } if (len < 5) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (str.charAt(2) != '_') { throw new IllegalArgumentException("Invalid locale format: " + str); } final char ch3 = str.charAt(3); if (ch3 == '_') { return new Locale(str.substring(0, 2), "", str.substring(4)); } final char ch4 = str.charAt(4); if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (len == 5) { return new Locale(str.substring(0, 2), str.substring(3, 5)); } if (len < 7) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (str.charAt(5) != '_') { throw new IllegalArgumentException("Invalid locale format: " + str); } return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
pos += Character.charCount(Character.codePointAt(input, pos));
if (str.startsWith("--")) { return null; }
return new BigDecimal(str);
if (zone.useDaylightTime()
if(currentStrategy.addRegex(this, regex)) {
boolean wasWhite= false;
if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append("\\s*+"); } continue; } wasWhite= false;
char[] buffer = new char[count];
if (start == 0 && end == 0) { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; }
return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
return cs1.equals(cs2);
for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) { Type toTypeArg = entry.getValue(); Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());
if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {
if (str.startsWith("0x") || str.startsWith("-0x")) {
int len = Character.codePointCount(input, 0, input.length());
else { //          // contract with translators is that they have to understand codepoints //          // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { if (pos < len - 2) { pos += Character.charCount(Character.codePointAt(input, pos)); } else { pos++; } } pos--; } pos++;
if (tokenLen >= 4) {
rule = selectNumberRule(Calendar.YEAR, tokenLen);
rule = TwoDigitYearField.INSTANCE;
if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
int end = start;
while(input.charAt(end) != ';')
return 2 + (end - start) + (isHex ? 1 : 0) + 1;
StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass());
if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {
return foundDigit && !hasExp;
Calendar c = new GregorianCalendar(mTimeZone);
if (expPos < decPos) {
mant = str.substring(0, expPos);
out.write(entityValue);
static float toJavaVersionInt(String version) {
return i;
if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
if (searchChars[j + 1] == cs.charAt(i + 1)) {
continue outer;
if (searchChars.indexOf(ch) < 0) {
return false;
return true;
return getRegistry().contains(new IDKey(value));
getRegistry().add(new IDKey(value));
getRegistry().remove(new IDKey(value));
classes[i] = array[i].getClass();
return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();
return m.containsKey(value);
type = Object.class;
return (T[]) new Object[] { null };
if (!Character.isDigit(lastChar)) {
return false;
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
calendar = (Calendar) calendar.clone();
int greater = replacementList[i].length() - searchList[i].length();
return contains(str.toUpperCase(), searchStr.toUpperCase());
return out;
if (className == null) {
int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
char c = str.charAt(i);
if (c > 0x7F) {
return appendTo == null ? null : appendTo.append(QUOTE);
if (val.startsWith("--")) {
if (upper == -1 || upper > str.length()) {
return escapeJavaStyleString(str, false);
escapeJavaStyleString(out, str, false);
return escapeJavaStyleString(str, true);
escapeJavaStyleString(out, str, true);
private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {
escapeJavaStyleString(writer, str, escapeSingleQuotes);
private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
out.write('\\');
int strLen = str.length();
int strLen = str.length();
isEquals = lhs.equals(rhs);
int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
if (locale != null) { key = new Pair(key, locale);
FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
if (locale == null) { locale = Locale.getDefault(); }
if (locale != null) { key = new Pair(key, locale);
FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
if (locale == null) { locale = Locale.getDefault(); }
}
switch (ch) {
out.write(ch);
if (field == Calendar.SECOND) { done = true; }
if (field == Calendar.MINUTE) { done = true; }
char ch4 = str.charAt(4);
stopTime = System.currentTimeMillis();
return cAvailableLocaleSet.contains(locale);
if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
str.getChars(0, strLen, buffer, size);
for (int i = 0; i < thisBuf.length; i++) {
for (int i = startIndex; i < thisBuf.length; i++) {
int len = thisBuf.length - strLen;
if (entityValue == -1) {
buf.append((char) (entityValue));
case 'x' : { entityValue = Integer.parseInt(entityContent.substring(2), 16);
if (entityValue == -1) {
writer.write(entityValue);
days += 31;
months -= 1;
milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds); seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds); minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes); hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours); days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days); months -= reduceAndCorrect(start, end, Calendar.MONTH, months); years -= reduceAndCorrect(start, end, Calendar.YEAR, years);
static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) { end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { int newdiff = startValue - endValue; end.add( field, newdiff ); return newdiff; } else { return 0; } }
return iValue - ((ValuedEnum) other).iValue;
for (int i = 0; i < fields.length; i++) {
val.set(fields[i][0], val.get(fields[i][0]) - offset);
throw new FractionConversionException(value, p2, q2);
throw new FractionConversionException(value, p2, q2);
return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();
final double[] prodHigh = new double[len];
Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
return NaN;
iterations = new Incrementor(0, new MaxIterCallback());
++iter;
if (checker.converged(iter, previous, current)) {
if (iter % n == 0 ||
final RealMatrix arz = randn1(dimension, lambda);
++iter;
stop = checker.converged(iter, previous, current);
if (iteration > 0) {
++iteration;
++iter;
converged = checker.converged(iter, previous, current);
++iter;
if (checker.converged(iter, previous, current)) {
currentEvent.stepAccepted(eventT, eventY); isLastStep = currentEvent.stop();
for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); }
boolean needReset = currentEvent.reset(eventT, eventY);
for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); }
public T[] sample(int sampleSize) throws NotStrictlyPositiveException {
final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);
final Line reverted = new Line(zero, zero.subtract(direction));
}
return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals);
final EigenDecomposition dec = new EigenDecomposition(m);
weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim); for (int i = 0; i < dim; i++) { weightMatrix.setEntry(i, i, weight[i]); }
final EigenDecomposition dec = new EigenDecomposition(m);
if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {
return 0.5 * exp(x);
if (x < -20) {
return 0.5 * exp(-x);
return 0.5 * exp(x);
if (x < -20) {
return -0.5 * exp(-x);
return multiplyFast(x);
res[i] = (x[i] - boundaries[0][i]) / diff;
res[i] = diff * x[i] + boundaries[0][i];
if (x[i] < 0) {
if (x[i] > 1.0) {
boundaries[1] = uB;
return decode(x);
swap[r] = r; for (int i = r + 1; i < order; ++i) { int ii  = index[i]; int isi = index[swap[i]]; if (c[ii][ii] > c[isi][isi]) { swap[r] = i; } }   // swap elements if (swap[r] != r) { int tmp = index[r]; index[r] = index[swap[r]]; index[swap[r]] = tmp; }
c[ii][ii] -= e * e;
return true;
return false;
return best(current, previous, isMinim);
return best(current, previous, isMinim);
return current;
return current;
a = FastMath.sqrt(c1 / c2);
if (a0 > overflow) {
if ((p2 > overflow) || (q2 > overflow)) {
return multiply(100).doubleValue();
for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow;
Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
return res;
final int n1n2prod = n1 * n2;
double cN = a * hPrev + b * p0; double q2 = a * q1 + b * dPrev; if (Double.isInfinite(cN) || Double.isInfinite(q2)) { double scaleFactor = 1d; double lastScaleFactor = 1d; final int maxPower = 5; final double scale = FastMath.max(a,b); if (scale <= 0) {  // Can't scale throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x); } for (int i = 0; i < maxPower; i++) { lastScaleFactor = scaleFactor; scaleFactor *= scale; if (a != 0.0 && a > b) { cN = hPrev / lastScaleFactor + (b / scaleFactor * p0); q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev); } else if (b != 0) { cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor; q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor; } if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) { break; } } }  final double deltaN = cN / q2 / cPrev; hN = cPrev * deltaN;
dPrev = q1; cPrev = cN / q2; p0 = hPrev; hPrev = cN; q1 = q2;
if ((Boolean) tree.getAttribute()) {
if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
return chromosomes.iterator();
this.elitismRate = elitismRate;
this.elitismRate = elitismRate;
return result;
return result;
if (isNaN) {
double imaginary2 = 2.0 * imaginary;
if (isNaN) {
double real2 = 2.0 * real;
throw new PathIsExploredException(); // XXX
final int iptMinus1 = ipt; final int jptMinus1 = jpt;
throw new PathIsExploredException(); // XXX
yTmp[j] = y[j] + stepSize * sum;
computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);
yTmp[j] = y[j] + stepSize * sum;
targetY = -REDUCTION_FACTOR * yB;
targetY = -REDUCTION_FACTOR * yA;
for (int i = 0; i < weights.length; i++) {
if (basicRows.contains(basicRow)) {
if (!(meanImpl instanceof Mean)) {
if (!(varianceImpl instanceof Variance)) {
if (!(geoMeanImpl instanceof GeometricMean)) {
resetOccurred = false;
return eventT;
return eventT;
this.rows = rowDimension;
return isZero ? NaN : INF;
return isZero ? NaN : INF;
if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {
return NaN;
return NaN;
break;
Iterator iter = res.entries.iterator();
Iterator iter = res.entries.iterator();
Iterator iter = res.entries.iterator();
Iterator iter = res.entries.iterator();
if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); }
default:
if (c == 0) {
if (c == 0) {
if (c == 0) {
return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
return;
if (lessThan(getZero())) {
return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
int idx = 1; while (count < index) { count += idx; ++idx; } --idx;
indices[last] = idx;
int sum = 0;
return fit(new Gaussian.Parametric(), guess);
return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);
try { return 0.5 * (1.0 + Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0)))); } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 return 0; } else if (x > (mean + 20 * standardDeviation)) { return 1; } else { throw ex; } }
throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);
return optimize(f, goal, min, max, 0);
final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));
return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
incrementIterationsCounter();
qTy(residuals);
sum += jacobian[i][pj] * residuals[i];
return current;
determineLMParameter(oldRes, delta, diag, work1, work2, work3);
current = new VectorialPointValuePair(point, objective);
} else { if (checker.converged(getIterations(), previous, current)) { return current; }
double criterion = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; criterion += residual * residual * residualsWeights[i]; }
return Math.sqrt(criterion / rows);
chiSquare += residual * residual / residualsWeights[i];
setMaxEvaluations(Integer.MAX_VALUE); setMaximalIterationCount(100); setAbsoluteAccuracy(1E-10); setRelativeAccuracy(1.0e-14);
throw new UnsupportedOperationException(); }
double fx = computeObjectiveValue(f, x); if (goalType == GoalType.MAXIMIZE) {
int count = 0; while (count < maximalIterationCount) {
double fu = computeObjectiveValue(f, u); if (goalType == GoalType.MAXIMIZE) {
setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count); return x; } ++count; } throw new MaxIterationsExceededException(maximalIterationCount);
return optimizer.getFunctionValue();
return optimizer.getResult();
return new VectorialPointValuePair(point, objective);
return new VectorialPointValuePair(point, objective);
out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
return solve(min, max);
loop     = false;
loop     = false;
setResult(yMin, 0);
setResult(yMax, 0);
return solve(f, min, yMin, max, yMax, initial, yInitial);
final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.length]; java.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance; }
return getCumPct((Comparable<?>) v);
eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
for (int i = 0; i < p - 1; ++i) {
ei1 = eData[i + 1];
wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
for (int i = 0; i < p - 1; ++i) {
wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
max += Math.max(max, Math.abs(a));
public double getLInfNorm() { double max = 0; Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); max += iter.value(); } return max; }
increasing = gb >= ga;
int sum = 0;
final int dp = p1[i] - p2[i];
int j = 4 * n - 1;
for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {
if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&
if (end - start > 2) {
if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {
int start = getNumObjectiveFunctions();
Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());
Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);
return;
if (fa * fb >= 0.0 ) {
if (lTData[i][i] < absolutePositivityThreshold) { throw new NotPositiveDefiniteMatrixException(); }
ltI[i] = Math.sqrt(ltI[i]);
if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { if (row == null) { row = i; } else { return null; }
coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative); if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { if (tableau.getEntry(basicRow, j) == 1) { coefficients[i] = 0; } }
addValue((Comparable<?>) v);
Object obj = v;
double nOd = doubleValue();
double dOn = object.doubleValue();
long result = Math.round(binomialCoefficientDouble(n, k)); if (result == Long.MAX_VALUE) { throw new ArithmeticException( "result too large to represent in a long integer"); } // Use symmetry for large k  // We use the formula // (n choose k) = n! / (n-k)! / k! // (n choose k) == ((n-k+1)*...*n) / (1*...*k) // which could be written // (n choose k) == (n-1 choose k-1) * n / k // For n <= 61, the naive implementation cannot overflow. // For n > 61 but n <= 66, the result cannot overflow, // but we must take care not to overflow intermediate values. // We know that (result * i) is divisible by j, // but (result * i) may overflow, so we split j: // Filter out the gcd, d, so j/d and i/d are integer. // result is divisible by (j/d) because (j/d) // is relative prime to (i/d) and is a divisor of // result * (i/d). // For n > 66, a result overflow might occur, so we check // the multiplication, taking care to not overflow // unnecessary. return result;
return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
for (int i = k + 1; i <= n; i++) {
long result = Math.round(factorialDouble(n)); if (result == Long.MAX_VALUE) {
return Math.floor(Math.exp(factorialLog(n)) + 0.5);
for (int i = 2; i <= n; i++) {
if (u * v == 0) {
double ret;
ret = d / (d - 2.0);
ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));
if (sign >= 0) {
throw new IllegalArgumentException ("Function values at endpoints do not have different signs." + "  Endpoints: [" + min + "," + max + "]" + "  Values: [" + yMin + "," + yMax + "]"); } else { // solve using only the first endpoint as initial guess ret = solve(min, yMin, max, yMax, min, yMin); // either min or max is a root }  return ret;
final BigDecimal[] out = new BigDecimal[v.length];
final double[] out = new double[v.length];
return (Math.abs(u) + Math.abs(v));
return lcm;
final int cols = problem.getAllParameters().length;
int p = problem.getAllParameters().length;
double[] errors = new double[problem.getAllParameters().length];
if ( source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter()) != 0) {
dev = ((double) observed[i] - expected[i]); sumSq += dev * dev / expected[i];
return 0.5 * (1.0 + Erf.erf((x - mean) /
(standardDeviation * Math.sqrt(2.0))));
return sumYY - sumXY * sumXY / sumXX;
return new Fraction(num.intValue(), 1);
int n = num.intValue();
throw new UnsupportedOperationException();
this.durationMillis = durationMillis;
for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);
throw new NoInteractionsWanted(join( "No interactions wanted here:", new LocationImpl(), "But found this interaction on mock '" + undesired.getMock() + "':", undesired.getLocation(), scenario ));
throw new VerificationInOrderFailure(join( "No interactions wanted here:", new LocationImpl(), "But found this interaction on mock '" + undesired.getMock() + "':", undesired.getLocation() ));
return details.getCause().getMessage();
catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
return reportMatcher(Any.ANY).returnFalse();
return reportMatcher(Any.ANY).returnZero();
return reportMatcher(Any.ANY).returnChar();
return reportMatcher(Any.ANY).returnZero();
return reportMatcher(Any.ANY).returnZero();
return reportMatcher(Any.ANY).returnZero();
return reportMatcher(Any.ANY).returnZero();
return reportMatcher(Any.ANY).returnZero();
return (T) reportMatcher(Any.ANY).returnNull();
return (T) reportMatcher(Any.ANY).returnFor(clazz);
return (T) anyObject();
return reportMatcher(Any.ANY).returnString();
return reportMatcher(Any.ANY).returnList();
return (List) reportMatcher(Any.ANY).returnList();
return reportMatcher(Any.ANY).returnSet();
return (Set) reportMatcher(Any.ANY).returnSet();
return reportMatcher(Any.ANY).returnMap();
return reportMatcher(Any.ANY).returnMap();
return reportMatcher(Any.ANY).returnList();
return (Collection) reportMatcher(Any.ANY).returnList();
registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));
} else { contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
return invocation.callRealMethod();
return recordDeepStubAnswer( newDeepStubMock(returnTypeGenericMetadata), container );
: withSettings();  return mockSettings.serializable()
return mockSettings.serializable()
return method.equals(o);
return 1;
return (Class) actual;
if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher); verificationMode.verify(data); return null;
mockingProgress.verificationStarted(mode);
new FieldSetter(fieldInstance, field).set(matchingMock);
return MOCKITO_CORE.mock(classToMock, mockSettings);
return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings() .spiedInstance(object) .defaultAnswer(CALLS_REAL_METHODS));
public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); }
mockingProgress.resetOngoingStubbing();
return this.extraInterfaces(java.io.Serializable.class);
return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);
ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;
return null;
return next.filterCandidate(mocks, field, fieldInstance);
mockInstance = classInstantiator.instantiate(mockedProxyType);
throw new MockitoException(join( "ClassCastException occurred while creating the mockito mock :", "  class to mock : " + describeClass(mockedProxyType), "  created class : " + describeClass(settings.getTypeToMock()), "  proxy instance class : " + describeClass(mockInstance), "  instance creation by : " + classInstantiator.getClass().getSimpleName(), "", "You might experience classloading issues, please ask the mockito mailing-list.", "" ),cce);
return withOuterClass(cls);
private <T> T withOuterClass(Class<T> cls) {
Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass()); return c.newInstance(outerClassInstance);
if (o1 == null || o2 == null) {
if (!mockitoCore.isTypeMockable(rawType)) {
return mockSettings
.defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
container.addAnswer(new Answer<Object>() {
return 1;
return getMock(invocation);
return recordDeepStubMock(invocation, container);
Class<?> clz = invocation.getMethod().getReturnType(); final Object mock = org.mockito.Mockito.mock(clz, this);
primitiveValues.put(double.class, 0);
MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));
mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
description.appendText(wanted.toString());
throw new SmartNullPointerException(join( "You have a NullPointerException here:", new Location(), "Because this method was *not* stubbed correctly:", location, "" ));
new Reporter().smartNullPointerException(location);
return invocation.getMethod().getName() + "()";
field.set(testClass, Mockito.spy(instance));
return m1.equals(m2);
if (m instanceof CapturesArguments) {
return reportMatcher(new InstanceOf(clazz)).<T>returnNull();
return reportMatcher(new Equals(value)).<T>returnNull();
return reportMatcher(new Same(value)).<T>returnNull();
return realMethod.invoke(mock, rawArguments);
public void validate(Answer<?> answer, Invocation invocation) { if (answer instanceof ThrowsException) { validateException((ThrowsException) answer, invocation); }  if (answer instanceof Returns) { validateReturnValue((Returns) answer, invocation); }  if (answer instanceof DoesNothing) { validateDoNothing((DoesNothing) answer, invocation); }  }
return StringDescription.toString(m).equals(arg.toString());
int compare = lastUnitField.compareTo(loopUnitField);
} else if (compare == 0) {
if (durationField.isSupported()) { return 1; }
if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
return 0;
setMillis(type.getField(getChronology()).add(getMillis(), amount));
setMillis(getChronology().years().add(getMillis(), years));
setMillis(getChronology().weekyears().add(getMillis(), weekyears));
setMillis(getChronology().months().add(getMillis(), months));
setMillis(getChronology().weeks().add(getMillis(), weeks));
setMillis(getChronology().days().add(getMillis(), days));
setMillis(getChronology().hours().add(getMillis(), hours));
setMillis(getChronology().minutes().add(getMillis(), minutes));
setMillis(getChronology().seconds().add(getMillis(), seconds));
setMillis(getChronology().millis().add(getMillis(), millis));
Partial newPartial = new Partial(iChronology, newTypes, newValues);
years = FieldUtils.safeAdd(years, months / 12); months = months % 12; if (years != 0) { result = result.withYears(years); } if (months != 0) { result = result.withMonths(months);
ArrayList<GJChronology> chronos = cCache.get(zone); if (chronos == null) { chronos = new ArrayList<GJChronology>(2); cCache.put(zone, chronos); } else { for (int i = chronos.size(); --i >= 0;) { chrono = chronos.get(i); if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) {  return chrono; } } } if (zone == DateTimeZone.UTC) { chrono = new GJChronology (JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); } else { chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); chrono = new GJChronology (ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant);
instant = gregorianToJulian(instant);
instant = gregorianToJulian(instant);
long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal);
if (minutesOffset < 0 || minutesOffset > 59) {
minutesOffset = hoursInMinutes - minutesOffset;
if (minutesOffset < 0 || minutesOffset > 59) {
int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);
minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);
minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);
String id = printOffset(millisOffset);
int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));
return new LocalDate( yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH) );
return new LocalDate( date.getYear() + 1900, date.getMonth() + 1, date.getDate() );
return new LocalDateTime( yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND) );
return new LocalDateTime( date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000 );
sum = Math.max(sum, 4);
buf.append('.'); FormatUtils.appendPaddedInteger(buf, dp, 3);
if (DateTimeUtils.isContiguous(partial)) {
return -val1;
DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (instantBefore == instantAfter) {
long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
} else if (offsetLocal > 0) {
bucket.setZone(DateTimeZone.forID(id)); return position + id.length();
return ~position;
String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); String[] setLoc = null; for (String[] strings : zoneStringsLoc) { if (strings != null && strings.length == 5 && id.equals(strings[0])) { setLoc = strings;  byNameKeyCache.put(setLoc[2], new String[] {setLoc[2], setLoc[1]}); // need to handle case where summer and winter have the same // abbreviation, such as EST in Australia [1716305] // we handle this by appending "-Summer", cf ZoneInfoCompiler if (setLoc[2].equals(setLoc[4])) { byNameKeyCache.put(setLoc[4] + "-Summer", new String[] {setLoc[4], setLoc[3]}); } else { byNameKeyCache.put(setLoc[4], new String[] {setLoc[4], setLoc[3]}); } break;
this(duration, null, null);
if (map == null) { // Backwards compatibility with TimeZone. map = new HashMap<String, String>(); map.put("GMT", "UTC"); map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu");  // JDK 1.1 compatible map.put("AST", "America/Anchorage"); map.put("PST", "America/Los_Angeles"); map.put("MST", "America/Denver");  // JDK 1.1 compatible map.put("PNT", "America/Phoenix"); map.put("CST", "America/Chicago"); map.put("EST", "America/New_York");  // JDK 1.1 compatible map.put("IET", "America/Indianapolis"); map.put("PRT", "America/Puerto_Rico"); map.put("CNT", "America/St_Johns"); map.put("AGT", "America/Buenos_Aires"); map.put("BET", "America/Sao_Paulo"); map.put("WET", "Europe/London"); map.put("ECT", "Europe/Paris"); map.put("ART", "Africa/Cairo"); map.put("CAT", "Africa/Harare"); map.put("EET", "Europe/Bucharest"); map.put("EAT", "Africa/Addis_Ababa"); map.put("MET", "Asia/Tehran"); map.put("NET", "Asia/Yerevan"); map.put("PLT", "Asia/Karachi"); map.put("IST", "Asia/Calcutta"); map.put("BST", "Asia/Dhaka"); map.put("VST", "Asia/Saigon"); map.put("CTT", "Asia/Shanghai"); map.put("JST", "Asia/Tokyo"); map.put("ACT", "Australia/Darwin"); map.put("AET", "Australia/Sydney"); map.put("SST", "Pacific/Guadalcanal"); map.put("NST", "Pacific/Auckland"); cZoneIdConversion = map; } return map.get(id);
millis -= iOffset; } else { int offset = iZone.getOffsetFromLocal(millis); millis -= offset; if (offset != iZone.getOffset(millis)) { String message = "Illegal instant due to time zone offset transition (" + iZone + ')'; if (text != null) { message = "Cannot parse \"" + text + "\": " + message; } throw new IllegalArgumentException(message); } }  return millis;
return offsetAdjusted;
return iZone.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, false);
long result = iZone.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, false);
sep = sep.finish(f.getPrinter(), f.getParser()); return new PeriodFormatter(sep, sep);
